# 📝 Solving: 구명보트 (42885)

## 문제 요약
- 무인도에 갇힌 사람들을 구명보트를 이용하여 구출하려고 함 
- 구명보트는 작아서 한 번에 최대 2명씩 밖에 탈 수 없고, 무게 제한도 있습니다.
- 사람들 몸무게가 담긴 배열 people과 보트의 무게제한 limit이 주어질 때, 모든 사람을 구출하기 위한 보트 개수의 최솟값을 return 하라.

## 접근 방법

- 이 문제를 풀기 위해서는 가장 가벼운 사람과 가장 무거운 사람을 보트에 같이 태울 수 있다면 그렇게 해야 최적의 구명보트 수를 구할 수 있다. 처음에는 인접한 사람끼리 태워서 보내면 되겠다고 생각했는데 테스트케이스는 통과했지만, 제출해보니 다른 많은 테케에서 실패했다 (40점으로 실패뜸) 따라서 이 문제는 가장 가벼운 사람+ 가장 무거운 사람끼리 묶어서 배를 태워 보내야 한다.

- 이를 위해서는 우선 사람들을 오름차순으로 정렬해준다.
- 그 후 while문을 돌려서 people.length가 빌때까지 반복문을 돌려주고 반복문 내부에서는 다음과 같은 로직이 필요하다.
    - people 배열에서 맨 마지막 사람을 뽑는다 (가장 뚱뚱한 사람)
    - people 배열의 맨 처음 사람과 아까 뽑은 가장 무거운 사람의 합이 limit과 같거나 작다면 맨 앞사람을 같이 태워 보내야하기에 people.shift()를 해준다.
    - cnt++을 통해 배 한대를 보낸다.

- 이렇게 하면 1회 반복당 배 한대를 보내는 것인데 조건문을 통해 맨 앞사람 + 맨 뒷사람이 limit과 같거나 작다면 맨 앞사람도 빼주는 방식을 통해 최적의 보트를 사용할 수 이씀

<details>
<summary>미묘하게 더 빠른 투 포인터 적용</summary>

```js
function solution(people, limit) {
    people.sort((a,b) => a - b);
    
    let cnt = 0;
    let [left, right] = [0, people.length - 1];

    while (left <= right) {
        if (people[left] + people[right] <= limit) {
            left++;
        }
        right--;
        cnt++;
    }

    return cnt;
}
```
- 기존 코드에서는 배열의 맨 앞을 제거하는 shift()를 사용했기에  people길이가 크다면 연산 시간이 오래 걸릴 수 있다. 
- 하지만 이 코드에서는 left, right 포인터 변수를 통해 people 배열을 조작하지 않기에 더 빠르다.

직접 프로그래머스에서 시간을 확인해보자

<details>
<summary>프로그래머스 시간 확인</summary>

```bash
// 투 포인터 left, right 사용
테스트 1 〉	통과 (18.79ms, 35.3MB)
테스트 2 〉	통과 (1.16ms, 33.4MB)
테스트 3 〉	통과 (1.23ms, 33.6MB)
테스트 4 〉	통과 (1.13ms, 33.4MB)
테스트 5 〉	통과 (0.74ms, 33.6MB)
테스트 6 〉	통과 (0.44ms, 33.5MB)
테스트 7 〉	통과 (0.64ms, 33.6MB)
테스트 8 〉	통과 (0.18ms, 33.3MB)
테스트 9 〉	통과 (0.22ms, 33.4MB)
테스트 10 〉   통과 (1.13ms, 33.4MB)
테스트 11 〉   통과 (1.01ms, 33.5MB)
테스트 12 〉   통과 (0.99ms, 33.5MB)
테스트 13 〉   통과 (1.15ms, 33.5MB)
테스트 14 〉   통과 (1.30ms, 33.5MB)
테스트 15 〉   통과 (0.24ms, 33.4MB)
테스트 16 〉   통과 (0.16ms, 33.4MB)
테스트 17 〉   통과 (0.17ms, 33.4MB)
테스트 18 〉   통과 (0.17ms, 33.4MB)
테스트 19 〉   통과 (0.17ms, 33.4MB)
테스트 20 〉   통과 (0.17ms, 33.4MB)
테스트 21 〉   통과 (0.16ms, 33.4MB)
테스트 22 〉   통과 (0.16ms, 33.5MB)
효율성  테스트
테스트 1 〉	통과 (13.86ms, 38.2MB)
테스트 2 〉	통과 (12.17ms, 38.3MB)
테스트 3 〉	통과 (12.74ms, 38MB)
테스트 4 〉	통과 (10.30ms, 38.4MB)
테스트 5 〉	통과 (11.89ms, 38MB)
채점 결과
정확성: 81.5
효율성: 18.5
합계: 100.0 / 100.0
```

```bash
테스트 1 〉	통과 (2.29ms, 35.3MB)
테스트 2 〉	통과 (1.17ms, 33.6MB)
테스트 3 〉	통과 (1.31ms, 33.5MB)
테스트 4 〉	통과 (1.25ms, 33.5MB)
테스트 5 〉	통과 (0.80ms, 33.5MB)
테스트 6 〉	통과 (0.47ms, 33.4MB)
테스트 7 〉	통과 (0.67ms, 33.5MB)
테스트 8 〉	통과 (0.17ms, 33.5MB)
테스트 9 〉	통과 (0.22ms, 33.4MB)
테스트 10 〉	통과 (1.21ms, 33.5MB)
테스트 11 〉	통과 (1.17ms, 33.5MB)
테스트 12 〉	통과 (1.10ms, 33.4MB)
테스트 13 〉	통과 (1.23ms, 33.5MB)
테스트 14 〉	통과 (1.44ms, 33.6MB)
테스트 15 〉	통과 (0.23ms, 33.6MB)
테스트 16 〉	통과 (0.16ms, 33.5MB)
테스트 17 〉	통과 (0.15ms, 33.5MB)
테스트 18 〉	통과 (0.15ms, 33.4MB)
테스트 19 〉	통과 (0.16ms, 33.4MB)
테스트 20 〉	통과 (0.15ms, 33.4MB)
테스트 21 〉	통과 (0.15ms, 33.4MB)
테스트 22 〉	통과 (0.15ms, 33.4MB)
효율성  테스트
테스트 1 〉	통과 (70.29ms, 37.9MB)
테스트 2 〉	통과 (13.06ms, 38.5MB)
테스트 3 〉	통과 (29.55ms, 38.2MB)
테스트 4 〉	통과 (11.02ms, 38.6MB)
테스트 5 〉	통과 (10.32ms, 38.2MB)
```
</details>

- 효율성 테스트 1번에서 시간 차이가 많이 난다.
- gpt한테 물어보니 시간복잡도가 첫 번째 코드는 o(n), 두 번째 코드는 o(n^)이라고 한다.
- 코딩 테스트 문제를 풀 때, 직접 배열을 조작하는것은 지양하자. (배열 맨 앞 요소 추가, 삭제)
</details>