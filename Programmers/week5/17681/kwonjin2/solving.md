# 📝 Solving: [1차] 비밀지도 (17681)

## 문제 요약
- 지도 크기: n * m
- 두 개의 암호화된 배열 arr1, arr2가 있을 때, 각 배열은 지도 각 줄의 정수를 암호화한 것
- 1: 벽, 0: 공백

- arr1, arr2를 겹쳐놨을 때 한 칸이라도 벽이 있으면 최종지도에서 벽
- 둘다 공백이면 최종지도에서도 공백
- row하나를 2진수로 표현하면 벽과 공백 정보를 얻을 수 있음
    arr1의 첫 줄
    - 01001: 여기서 0은 공백 1은 #임
    arr2의 첫 줄
    - 11110: 여기서 0은 공백 1은 #임

    이 두개를 OR 연산하면 11111

    따라서 최종 지도의 첫 줄은 11111임

## 접근 방법

/*
이 문제는 지도1, 지도2의 OR연산한 값을 지도로 만드는게 핵심이다.
결국 지도1에서의 공백과 벽의 2진수 코드를 10진수 형태로 전달해주고 있고 
찐 지도 가로1줄은 지도1(1줄) | 지도2(1줄)로 구할 수 있다.
10진수 -> 2진수 변환: toString(2);

for문을 통해 지도1과 지도2를 OR연산한 값을 result배열에 담아준다. 이때 n의 길이보다 OR 연산한 값이
더 작게 나올 수 있기에 padStart(n, 0)을 통해 연산 결과가 
n 보다 작다면 n길이에 맞게 앞에 0을 채워준다.

그러면 ["111111","111001","110011","011110","011111", "111010"] 이러한 형태로 나오고
여기서 '1' -> '#'으로, '0' -> ''(공백)으로 바꿔서 리턴하면 된다.
*/


