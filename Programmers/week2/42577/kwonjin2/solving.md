# 📝 Solving: 전화번호 목록 (42577)

## 문제 요약

- 전화번호부에 적힌 번호들 중에서, 어떤 번호가 다른 번호의 접두어인 경우가 있는지 확인하는 문제.
- 접두어 관계가 있으면 false 반환
- 접두어 관계가 없으면 true 반환

- 예시
  - ["119", "97674223", "1195524421"] → "119"가 "1195524421"의 접두어 → false
  - ["123", "456", "789"] → 접두어 없음 → true
  - ["12", "123", "1235", "567", "88"] → "12"가 "123"의 접두어 → false

## 접근 방법

기존 풀이 방식

```js
function solution(phone_book) {
  for (let i of phone_book) {
    let filter_i = phone_book.filter((p) => p !== i);
    let prefix = filter_i.map((str) => str.slice(0, i.length));
    if (prefix.some((str) => str.includes(i))) {
      return false;
    }
  }
  return true;
}
```

phone_book를 돌면서 i를 제외한 배열을 담은 변수인 filter_i를 만듬
["119", "97674223", "1195524421"] 이 경우엔 filter_i가
["97674223", "1195524421"]
["119", "1195524421"]
["119", "97674223"] 이런 순서로 만들어짐
그 다음 prefix 변수를 만들어줄건데 애는 filter_i를 돌면서 i.length만큼 문자열을 자를거임
["97674223", "1195524421"] 이 경우엔 prefix에
["976", "119"] << 이런식으로 담김
이제 이 배열에 i(119)가 포함되어있는지 판단 여부에 따라 true/false를 리턴한다.

정답 접근 방식

먼저 phone_book를 사전순 정렬한다.
그러면 ["119", "97674223", "1195524421"] 이 배열이 ["119","1195524421", "97674223" ] 이렇게 됨

이제 반복문을 돌리는데 for(let i = 0; i < phone_book.length - 1; i++)을 하여 첫 요소와 두 번째 요소만 비교할 것이다.

if 만약 두번째 요소 시작이 첫 요소로 시작한다면 false를 반환하고 그렇지 않다면 true를 반환한다.

후기: 뭔가 계속 고민했는데 정렬을 해야한다는 생각은 떠올리지 못했다. 게다가 위 코드처럼 굳이 3개를 다 비교하지 않고 하나라도 접두사이면 된다는 점을 활용해서 정렬을 하면 접두사가 바로 옆에 붙는다는 것을 이용한 것이 신기했다. 꾸준히 풀어서 나중에는 이런 생각을 스스로 할 수 있도록 해야겠다.
