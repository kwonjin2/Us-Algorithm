# [1844] 게임 맵 최단거리

```pyhton
from collections import deque

def solution(maps):
    # 동 서 남 북
    dr = [0, 0 ,1 ,-1] 
    dc = [1, -1, 0, 0]
    move_count_index = 1
    n, m = len(maps), len(maps[0])
    
    visited = [[False] * m for _ in range(n)]
    visited[0][0] = True
    
    queue = deque([[0, 0, 1]])
    
    while queue:
        r, c, d = queue.popleft()

        if r == n -1 and c == m -1:
            return d
        
        for i in range(4):
            new_r, new_c = r + dr[i], c + dc[i]
            
            if 0 <= new_r < n and 0 <= new_c < m and maps[new_r][new_c] == 1 and not visited[new_r][new_c]:
                visited[new_r][new_c] = True
                queue.append([new_r, new_c, d + 1])
    
    return -1
```

## 접근 방식

- 상대 팀 진영에 최대한 빨리 도착하면 게임 승
- 5 X 5 크키의 맵이고, 캐릭터는 row 1 col 1 에 위치
- 상태 팀 진영은 5 X 5 에 위치 한다.
- 벽인 부분은 갈 수 없다.또한 맵 밖도
- 방향은 동, 서, 남, 북 의 방향성을 가지고 한칸 씩 이동한다.

---
 
- 최단거리의 수 BFS를 사용
- 동, 서, 남, 북
- dr[0, 0, 1, -1]
- dc[1,-1, 0, 0]
- 맵의 크기 `n x m` 이니까 len(maps), lan(maps[0])
- 방문 했던 공간을 만들기 위해 visited 만들고 False
- 큐에 row, col, 횟수
- 방향을 가지니까 4번 반복



