# [1844] 게임 맵 최단거리

```java
// 상대 진영에 먼저 파괴하는 쪽이 승이 -> 최단 거리
// 11칸 이동, 15칸 이동으로 파괴 가능하다면 11칸을 리턴
// 동, 서, 남, 북 방향을 가지고 한 칸 씩 이동
// 상대 진영에 도착할 수 없는 맵이라면 -1 반환
// 이동 가능 구역 : 1
// 벽 : 0

// BFS -> Queue

import java.util.*;

class Solution {
    public int solution(int[][] maps) {
        int[] dr = {0, 0, 1, -1};
        int[] dc = {-1, 1, 0, 0};
        
        int n = maps.length; // 세로
        int m = maps[0].length; // 가로
        
        boolean[][] visited = new boolean[n][m];
        Queue<int[]> queue = new LinkedList<>();        
        
        queue.offer(new int[]{0, 0, 1});
        visited[0][0] = true;
        
        while(!queue.isEmpty()){
            int[] cur = queue.poll();
            int r = cur[0];
            int c = cur[1];
            int dist = cur[2];
            
            if(r == n - 1 && c == m -1){
                return dist;
            }
            
            for(int i = 0; i < 4; i++){
                int newR = r + dr[i];
                int newC = c + dc[i];
                
                if(0 <= newR && newR < n && 0 <= newC && newC < m 
                   && maps[newR][newC] == 1 
                   && !visited[newR][newC]){
                    
                   visited[newR][newC] = true;
                    queue.offer(new int[]{newR, newC, dist + 1});
                }
            }
        }
        return -1;
    }
}
```

```pyhton
from collections import deque

def solution(maps):
    # 동 서 남 북
    dr = [0, 0 ,1 ,-1] 
    dc = [1, -1, 0, 0]
    move_count_index = 1
    n, m = len(maps), len(maps[0])
    
    visited = [[False] * m for _ in range(n)]
    visited[0][0] = True
    
    queue = deque([[0, 0, 1]])
    
    while queue:
        r, c, d = queue.popleft()

        if r == n -1 and c == m -1:
            return d
        
        for i in range(4):
            new_r, new_c = r + dr[i], c + dc[i]
            
            if 0 <= new_r < n and 0 <= new_c < m and maps[new_r][new_c] == 1 and not visited[new_r][new_c]:
                visited[new_r][new_c] = True
                queue.append([new_r, new_c, d + 1])
    
    return -1
```

## 접근 방식

- 상대 팀 진영에 최대한 빨리 도착하면 게임 승
- 5 X 5 크키의 맵이고, 캐릭터는 row 1 col 1 에 위치
- 상태 팀 진영은 5 X 5 에 위치 한다.
- 벽인 부분은 갈 수 없다.또한 맵 밖도
- 방향은 동, 서, 남, 북 의 방향성을 가지고 한칸 씩 이동한다.

---
 
- 최단거리의 수 BFS를 사용
- 동, 서, 남, 북
- dr[0, 0, 1, -1]
- dc[1,-1, 0, 0]
- 맵의 크기 `n x m` 이니까 len(maps), lan(maps[0])
- 방문 했던 공간을 만들기 위해 visited 만들고 False
- 큐에 row, col, 횟수
- 방향을 가지니까 4번 반복



