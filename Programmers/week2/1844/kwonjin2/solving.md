# 📝 Solving: 게임 맵 최단거리 (1844)

## 문제 요약

- 맵: n \* m 크기의 2차원 배열 (1 = 이동 가능, 0 = 벽)
- 시작점: 0, 0 (좌측 상단)
- 도착점: n-1, m-1 (우측 하단)
- 이동 규칙: 상, 하, 좌, 우 한 칸씩만 이동 가능
- 목표: 시작점에서 도착점까지 이동할 수 있는 최단 칸 수 구하기
- 이동 불가능하면 -1 반환

## 접근 방법

먼저 이 문제는 BFS를 통해 해결해야 한다.

BFS 개념을 들어보기만 했기에 강의를 보면서 BFS 원리에 대해 학습했다.

먼저 totalRow와 totalCol을 미리 구해준다.

그 후 상, 하, 좌, 우 이동을 위한 directions를 만들어준다.
2차원 배열이 5\*5라고 가정했을 때, 아래와 같다. (편의상 1,2,3,4,5로 그렸다.)
[
[1,2,3,4,5],
[6,7,8,9,10],
[11,12,13,14,15],
[16,17,18,19,20],
[21,22,23,24,25],
]

여기서 현재 로봇의 값은 0,0인 1이다. 여기서 아래 6으로 이동하려면 현재 위치 [0] + [1], [0] + [0]이 되어야한다.
상하좌우는 다음과 같이 표현한다.

[1, 0] 아래로 이동
[-1, 0] 위로 이동
[0, 1] 오른쪽으로 이동
[0, -1] 왼쪽으로 이동

그리고 로봇이 이동한 칸수를 세기위해 -1로 채워진 n \* m 배열을 만들고, 초기 시작점 0,0은 1로 설정해준다. (문제 조건임)

이제 BFS를 돌리기 위해 queue를 만들어주고 첫 요소에 로봇의 초기 위치 (0,0)를 넣어준다.
그리고 이 큐에 있는 요소를 빼기 위해 원래는 js 메서드인 shift()를 사용했지만, 시간초과가 나와서 head 변수(helper 변수)를 만들어줬다.

while (head < queue.length) {} 로, head가 queue의 길이가 될때까지 반복문을 돌려준다.

const [currentRow, currentCol] = queue[head]; 를 통해 queue[head]값을 구조분해할당 해준다.
그리고 head의 값을 ++ 해줘야한다. (shift메서드를 사용할 때완 다르게 queue에는 이동경로가 쌓임).

여기서 currentRow === totalRow - 1 이고 currentCol === totalCol -1이라면, 도착지점에 도착했으니,
return distanceArray[currentRow][currentCol] 해준다.

조건식에 통과되지 않았다면 로봇을 상하좌우로 이동할 수 있는지 조건문을 통해 검사해야한다.

이를 위해 directions에 대해 for of문을 돌리고 nextRow, nextCol 변수를 만들어줘야한다.
for (let [row, col] of directions) {
nextRow = row + currentRow
nextCol = col + currentCol
}
이렇게 구해줄 수 있다.

그리고 이 경로가 다음과 같은 조건식에 해당해야한다.

1. nextRow가 totalRow 범위에 있는지
2. nextCol가 totalCol 범위에 있는지
3. 로봇이 이동한 위치가 1인지 (0이면 이동 불가함 벽이라)
4. 한번도 방문하지 않았는지 (-1로 된 n \* m 배열을 만든 이유)

이 조건식에 해당한다면 로봇이 이동할 수 있는 칸이고
이동한 칸에 현재 위치 + 1을 해준다 (로봇의 초기 위치 값은 1이고 다음 이동 위치 값은 2가 되고.. 3이되고.. 이런식)
그리고 queue에 로봇이 이동하기 위해 사용된 nextRow, nextCol 값을 넣어준다.

그러면 while문이 반복하면서 로봇이 이동할 수 있는 경로에 1,2,3,4,5.. 이런식으로 이동칸수를 알 수 있게 표시를 할 것이고

로봇이 한칸씩 이동할 때마다 47,48라인에 적은 도착지점이라면 현재 로봇위치의 값을 반환한다.

만약 로봇이 도착지점에 가지 못한다면 queue에 새로운 좌표를 넣지 못하기에 head < queue.length 가 성립하지 않게 되고 while문을 빠져나오게된다. 그렇게되면 마지막으로 return -1을 해주면 끗.

후기 : BFS 처음 공부하면서 어렵고 이 문제를 너무 많이 풀어서 뭔가 로직을 통채로 외워버린 느낌이 조금 드는거 같다.
살면서 첫 BFS를 풀어본거라 아직 많이 부족하지만 다른 유형의 BFS를 풀면서 BFS문제를 정복하고 싶어져따.
