# 📝 Solving: 게임 맵 최단거리 (1844)

## 문제 요약

- 맵: n \* m 크기의 2차원 배열 (1 = 이동 가능, 0 = 벽)
- 시작점: 0, 0 (좌측 상단)
- 도착점: n-1, m-1 (우측 하단)
- 이동 규칙: 상, 하, 좌, 우 한 칸씩만 이동 가능
- 목표: 시작점에서 도착점까지 이동할 수 있는 최단 칸 수 구하기
- 이동 불가능하면 -1 반환

## 접근 방법

이 문제는 DP로 풀어야한다는것을 gpt를 통해 알았다.
(아직 문제만 보고 유형을 맞추는 경지에 오르지는 못했다.)

DP는 최적부분구조 + 중복되는구조가 있어야하는데 이 문제는 경우의 수를 구하는
문제라서 중복되는 구조가 있을 것이다.

n = 1일 경우에는 바닥 => 세로2 가로1의 바닥을 타일로 채우려면 타일을 세로로 배치하는 경우 1개만 존재

n = 2일 경우에는 바닥 => 세로2 가로2의 바닥을 타일로 채우려면 타일을 가로로 두개 쌓는 경우와 세로로 두개 배치하는 경우 2개 존재

n = 3일 경우에는 바닥 => 세로2 가로3의 바닥을 타일로 채우려면 타일을 세로, 가로2개 쌓기, 세로3개 나란히 배치 가로2개 먼저 쌓고 세로하나 배치 => 총 3개 경우의 수

n = 4일 경우에는 바닥 => 세로2 가로4, 타일로 채우려면 타일을 세로1, 가로2개겹침, 세로1의 경우와 세로2개 나란히 배치, 가로2개 쌓기의 경우와, 가로2개쌓기,세로두개 나란히 배치의 경우, 가로2개쌓기 \*2의 경우, 세로로만 4개 나란히 배치하는 경우 총 5개의 경우의 수

1,2,3,5... 를 봐서 피보나치 수열 문제이다. 피보나치 수열문제는 어떻게 푸는지에 따라 시간복잡도 차이가 크다.

재귀식을 바로 해버리면, 중복되는 계산식을 계속 처리해야해서 n의 크기가 커질수록 시간복잡도가 기하급수적으로 늘어난다.

그래서 DP 개념에서 메모이제이션이라는 것을 배웠다. 상향식, 하향식 방법이 있는데 기본적인 탑다운(하향식)방법에서는 재귀식 + 메모이제이션인데 콜스택의 제한 개수가 있어서 n이 클 경우엔 스택오버플로우 현상이 나타나서 상향식 방법인 타블레이션 방식으로 풀면 좋을 것 같다.

- 먼저 memo 변수를 만들어주고 [undefined, 1, 2]로 초기화 해준다.
- 그 다음 반복문을 통해 메모 memo[i] = (memo[i - 1] + memo[i - 2]) % 1000000007을 해준다.

- 마지막으로 return memo[n]을 해준다.
