# 📝 Solving: [12914 멀리 뛰기](https://school.programmers.co.kr/learn/courses/30/lessons/12914)

## 문제 요약

- 한 번에 1칸/2칸 뛸 수 있음
- 총 칸의 수 `n`에 대해, 맨 끝 칸에 도달하는 방법의 수 `% 1234567` return
- 1 <= `n` <= 2000

---

## 풀이 방법

- DP
- `n = 1`, 1칸 => 1
- `n = 2`, 2칸 => 2
- `n = 3`, (`n = 1`) + 2칸 / (`n = 2`) + 1칸 => 3
- `n = 4`, (`n = 2`) + 2칸 / (`n = 3`) + 1칸 => 5
- ...
- `n = m`, (`n = m - 2`) + 2칸 / (`n = m - 1`) + 1칸 => `n = m -2`의 경우의 수 + `n = m - 1`의 경우의 수
- *dp[0] = 1, dp[1] = 1로 초기 세팅


---

## 추가 메모

- `solution()`: 상향식 (Bottom-up) DP = 반복문 + 타뷸레이션
- `solution_2()`: 하향식 (Top-down) DP = 재귀 + 메모이제이션
- 대부분의 경우 상향식(Bottom-up, 반복문)이 하향식(Top-down, 재귀)보다 실제 실행 속도가 더 빠름
- 모든 부분 문제를 다 풀 필요가 없을 때만 하향식이 더 효율적