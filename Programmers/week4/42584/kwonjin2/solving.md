# 📝 Solving: 주식 가격 (42584)

## 문제 요약
- 주어진 prices 배열은 매 초마다의 주식 가격을 나타냄
- 각 시점마다 가격이 떨어지지 않은 기간(초)을 구해야 함


## 접근 방법
- 처음에는 이중 반복문을 통해 해결했다.
```js
function solution(prices) {
    const result = [];
    
    for (let i = 0; i < prices.length; i++) {
        let count = 0;
        for (let j = i + 1; j < prices.length; j++) {
            count++;
            if (prices[j] < prices[i]) break;
        }
        result.push(count);
    }
    
    return result;
}
```
- 이대로 최종 제출을 해도 통과하지만 스택으로도 풀 수 있었다.

- 먼저 스택을 활용한 접근 방식은 스택에 가격이 아직 떨어지지 않은 시점의 인덱스를 저장하는 것이다.
    - 그렇게 되면 예를 들어 prices = [1,2,3,2,3]이 저장되어있을 때, 다음과 같다.
    - 1초(가격 1) -> 스택에 [0];
    - 2초(가격 2) -> 스택에 [0,1];
    - 3초(가격 3) -> 스택에 [0,1,2];
    - 4초(가격 2) -> 현재 가격 2가 스택의 가격3보다 작으니 떨어진 것임. 2번째 인덱스는 3번째 인덱스에서 떨어졌다. -> result[2] = 1초 -> 스택에서 pop
    이런식으로 구현해볼 수 있다.

- 먼저 stack과 result 배열을 각각 만들어준다.
- 그리고 초의 흐름을 계산하기 위해 for문을 돌려준다. 이 for문은 prices.length까지 1씩 증가하는 반복문이다.
- 그리고 해당 for문 내부에는 while문으로 스택이 비어있지 않거나, 현재 가격이 스택의 마지막 가격보다 작다면 반복문을 실행하고 그렇지 않다면 스택에 해당 초를 넣는다.(떨어지지 않은 시점 인덱스) 만약 while 이 실행된다면 그것은 해당 가격이 스택의 마지막 가격보다 작다는 것이고, 그 말은 가격이 떨어진 것이다. 가격이 떨어졌다면 스택의 마지막 값을 통해 현재 지난 초 - 스택의 마지막 인덱스 값을 통해 가격이 떨어진 초를 구하여 result에 넣어준다. 해당 인덱스의 값이 떨어진 초를 넣어주기 위해서는 result[top] = i - top;을 통해 넣어줘야한다. 이 코드의 의미는 다음과 같다
- 가격이 떨어질 때까지 걸린시간 = 현재시점(i) - 시작 시점(top);

- 이렇게 반복문이 종료되면 남은 스택을 처리해줘야 한다.
- while문을 통해 stack이 비어있지 않을 때까지 반복문을 돌려주고, stack을 하나씩 빼서 result[top]에 넣어준다.
- 마지막 시점까지 가격이 떨어지지 않은 것이니 result[top] = prices.length - 1 - top;을 통해 마지막 시점까지로 계산해준다.

- 마지막으로 result를 반환해준다.