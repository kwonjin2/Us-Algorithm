# 📝 Solving: 프로세스 (42587)

## 문제 요약
- 운영체제가 다음 규칙에 따라 프로세스를 관리할 경우 특정 프로세스가 몇 번째로 실행되는지 알아내면 됩니다.
    1. 실행 대기 큐(Queue)에서 대기중인 프로세스 하나를 꺼냅니다.
    2. 큐에 대기중인 프로세스 중 우선순위가 더 높은 프로세스가 있다면 방금 꺼낸 프로세스를 다시 큐에 넣습니다.
    3. 만약 그런 프로세스가 없다면 방금 꺼낸 프로세스를 실행합니다.
        3.1 한 번 실행한 프로세스는 다시 큐에 넣지 않고 그대로 종료됩니다.
- 예를 들어 다음과 같은 우선순위 배열이 있다고 가정할 때, ABCD에 맞게 치환해보자.
  [2 1 3 2]
  [A B C D]
  큐는 순서대로 나와야하기에 A부터 순서대로 꺼낸다. (2-> 1-> 3-> 2 순서대로 꺼낸다.)
A(2) 꺼냄 -> C(3)있으니 다시 큐에 넣음
B(1) 꺼냄 -> C(3)있으니 다시 큐에 넣음
C(3) 꺼냄 -> 대기중인 큐 중 우선순위 가장 높으니 실행
현재 큐: [D, A, B]
D(2) 꺼냄 -> 대기중인 큐 중 우선순위 가장 높으니 실행
현재 큐: [A, B]
A(2) 꺼냄 -> 실행
현재 큐: [B]
B(1) 꺼냄 -> 실행

C -> D -> A -> B 순서대로 실행
이때, location이 주어지면 이 location에 해당하는 프로세스가 몇 번째로 실행되는지 return 하라
[A,B,C,D] 프로세스가 있을 때, location이 2라면 C를 가리키는 것이다. (2번 인덱스)


## 접근 방법
- 먼저 queue를 만들어준다. 이 queue에는 매개변수로 주어진 priority와 idx를 함께 보관해야 한다. 중복된 숫자에 대한 우선순위를 찾기 위해서이다. map 메서드를 이용해서 queue에  priority와 idx를 함께  보관한다.

- 프로세스가 실행될 때마다 증가할 count 변수를 0으로 초기화해준다.

- 이제 큐가 빌때까지 while문을 돌리고 해당 반복문 내에서는 다음과 같이 동작하게 만든다.
    1. 우선순위와 인덱스가 함께 저장되어있는 queue에서 구조분해 할당을 통해 [priority, idx]로 꺼낸다.
    2. priority가 남은 큐의 항목들 중 제일 크거나 같아야 한다. 이때 Math.max 메서드를 이용한다. 주의사항으로는 ...queue.map(val=>val[0])으로 priority만 보내야 한다. 이 조건이 충족한다면 프로세스가 실행될 수 있으므로 count++를 통해 프로세스를 실행한다.
    3. 그리고 실행한 프로세스의 idx가 location과 같다면 return count를 통해 location에 해당하는 프로세스가 실행된 순서를 반환해준다.
    4. 프로세스의 idx가 location과 같지 않다면 [priority, idx]를 queue에 다시 푸시해준다.